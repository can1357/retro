Includes = [
	"<retro/ir/builtin_types.hxx>"
]
Forwards = [
	"type"
]

# T    read_reg<T>  reg:id
[insn.read_reg]
side-effects   = false
is-const =       false
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.reg"]
templates =      [1,            0]
names =          ["",           "register"]

#void write_reg<T> reg:id	T:value
[insn.write_reg]
side-effects   = true
is-const =       false
template-count = 1
types =          ["@type.none", "@type.reg", "@type.none"]
templates =      [0,            0,           1]
names =          ["",           "register",  "value"]

#T    load_mem<T>  uptr:adr	
[insn.load_mem]
side-effects   = false
is-const =       false
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.ptr64"]
templates =      [1,            0]
names =          ["",           "pointer"]

#void store_mem<T> uptr:adr	T:value
[insn.store_mem]
side-effects   = true
is-const =       false
template-count = 1
types =          ["@type.none", "@type.ptr64", "@type.none"]
templates =      [0,            0,             1]
names =          ["",           "pointer",     "value"]

#T    undef<T>
[insn.undef]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none"]
templates =      [1]
names =          [""]
constexprs =     []

#T    poison<T>    str:Reason
[insn.poison]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.str"]
templates =      [1,            0]
names =          ["",           "Reason"]
constexprs =     [1]

#Ty   uext<Tx,Ty>  Tx:value
[insn.uext]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 2
types =          ["@type.none", "@type.none"]
templates =      [2,            1]
names =          ["",           "value"]
#Ty   iext<Tx,Ty>  Tx:value
[insn.iext]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 2
types =          ["@type.none", "@type.none"]
templates =      [2,            1]
names =          ["",           "value"]
#Ty   cast<Tx,Ty>  Tx:value
[insn.cast]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 2
types =          ["@type.none", "@type.none"]
templates =      [2,            1]
names =          ["",           "value"]
#Ty   bitcast<Tx,Ty>  Tx:value
[insn.bitcast]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 2
types =          ["@type.none", "@type.none"]
templates =      [2,            1]
names =          ["",           "value"]


#T    binop<T>     Op:Operator  T:lhs  T:rhs
[insn.binop]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.op", "@type.none", "@type.none"]
templates =      [1,            0,          1,            1]
names =          ["",           "Operator", "lhs",        "rhs"]
constexprs =     [1]
#T    unop<T>     Op:Operator  T:rhs
[insn.unop]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.op", "@type.none"]
templates =      [1,            0,          1]
names =          ["",           "Operator", "rhs"]
constexprs =     [1]
#i1    cmp<T>     Op:Operator  T:lhs  T:rhs
[insn.cmp]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.i1", "@type.op", "@type.none", "@type.none"]
templates =      [0,          0,          1,            1]
names =          ["",         "Operator", "lhs",        "rhs"]
constexprs =     [1]
#T     phi<T>     Tx...
[insn.phi]
side-effects   = false
is-const =       false
template-count = 1
types =          ["@type.none", "@type.pack"]
templates =      [1,            0]
names =          ["",           "incoming"]

#T    select<T>   i1:cc  T:tv T:fv
[insn.select]
side-effects   = false
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.i1", "@type.none", "@type.none"]
templates =      [1,            0,          1,            1]
names =          ["",           "cc",      "tv",          "fv"]
constexprs =     [1]

#void  xcall      uptr:destination
[insn.xcall]
side-effects   = true
is-const =       false
template-count = 0
types =          ["@type.none", "@type.ptr64"]
templates =      [0,            0]
names =          ["",           "destination"]

#void  jmp        uptr:destination
[insn.jmp]
side-effects   = true
is-const =       false
terminator =     true
template-count = 0
types =          ["@type.none", "@type.ptr64"]
templates =      [0,            0]
names =          ["",           "destination"]

#void  br        label:destination
[insn.br]
side-effects   = true
is-const =       false
terminator =     true
template-count = 0
types =          ["@type.none", "@type.label"]
templates =      [0,            0]
names =          ["",           "destination"]

#void  brc       i1:cc  label:tb label:fb
[insn.brc]
side-effects   = true
is-const =       false
terminator =     true
types =          ["@type.none", "@type.i1", "@type.label", "@type.label"]
templates =      [0,            0,          0,            0]
names =          ["",           "cc",      "tb",          "fb"]

#void  ret<T>    T:result
[insn.ret]
side-effects   = true
is-const =       false
terminator =     true
template-count = 1
types =          ["@type.none", "@type.none"]
templates =      [0,            1]
names =          ["",           "result"]

#void  unreachable
[insn.unreachable]
side-effects   = true
is-const =       false
terminator =     true
template-count = 0
types =          ["@type.none"]
templates =      [0]
names =          [""]


#TODO:
#  -- vector stuff
#  T    intrinsic<T> str:name, Ty:ArgOrTup // lsb,msb,popcnt,sin,cos,memcpy,readgs,atomic,can represent all things we dont care about
#  Tup  insert       Tup, int:idx, Ty:value
#  T    extract      Tup
#  R    call<R, A>   uptr:adr A:arg CC:CallConvention