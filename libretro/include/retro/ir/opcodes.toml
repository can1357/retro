Includes = [
	"<retro/ir/builtin_types.hxx>"
]
Forwards = [
	"type"
]


Script = """
# Generate the visitor for creating the constructors.
#
insns = data["opcode"]
for k,v in insns.items():
	# Set the opcode.
	#
	func = CxxFunction()

	# Start by setting the opcode.
	#
	func.stmts.append("r->op = opcode::" + k)

	# If instruction is templated:
	#
	for i in range(v.get("template-count", 0)):
		# Determine if we can deduce this template.
		#
		arg_match = 0
		for j in range(1, len(v["types"])):
			if v["templates"][j] == (i+1):
				arg_match = j
				break

		# If we cant, explicitly ask for it.
		#
		if arg_match == 0:
			func.add_argument("type", "t" + str(i))
			func.stmts.append("r->template_types[{0}] = t{0}".format(i))
		# Otherwise, deduce.
		#
		else:
			func.post_stmts.append("r->template_types[{0}] = r->operands()[{1}].get_type()".format(i, arg_match-1))

	# For each argument:
	#
	fixed_arg_count =   0
	var_arg_sentinels = []
	for i in range(1, len(v["types"])):
		argname = v["names"][i].lower()
		fixed_arg_count += 1

		# If constexpr, request the real type.
		#
		if i in v.get("constexprs", []):
			func.add_argument("type_t<type::" + v["types"][i][6:] + ">", argname)
			func.stmts.append("r->set_operands({0}, {1})".format(i-1, argname))
		# Otherwise if vararg:
		#
		elif v["types"][i] == "@type.pack":
			fixed_arg_count -= 1
			var_arg_sentinels.append("sizeof...(T{0})".format(argname))
			tname = func.add_argument_pack(argname)
			func.stmts.append("r->set_operands({0}, std::forward<{2}>({1})...)".format(i-1, argname, tname))
			assert (i+1) == len(v["types"]);
		# Finally accept any value.
		#
		else:
			tname = func.add_argument(None, argname)
			func.stmts.append("r->set_operands({0}, std::forward<{2}>({1}))".format(i-1, argname, tname))
		
	# Finally add the allocation with operand count and return the result.
	#
	var_arg_sentinels.append(str(fixed_arg_count))
	func.stmts.insert(0, "auto r = insn::allocate({0})".format("+".join(var_arg_sentinels)))
	
	# Add validation.
	#
	func.post_stmts.append("r->validate().raise()")

	
	# Copy into two and generate the code.
	#
	oprhan_ctor = func.clone()
	oprhan_ctor.return_type = "ref<insn>"
	oprhan_ctor.post_stmts.append("return r")
	oprhan_ctor = oprhan_ctor.write("make_" + k)

	bb_ctor = func.clone()
	bb_ctor.return_type = "insn*"
	bb_ctor.post_stmts.append("return this->push_back(std::move(r))")
	bb_ctor = bb_ctor.write("push_" + k)

	#print(oprhan_ctor + "\\n" + bb_ctor)

	# Set the visitor arg.
	v["VisitorArgs"] = ["RC_IDENTITY(" + oprhan_ctor.replace("\\n", "") + ")", "RC_IDENTITY(" + bb_ctor.replace("\\n", "") + ")"]
"""
 

opcode_kind = [
	"memory",
	"arch",
	
	"data",
	"cast",
	
	"numeric",
	"numeric-rmw",

	"predicate",
	"phi",
	"branch",
	"external-branch",
	
	"trap"
]

# T    read_reg<T>  reg:id
[opcode.read_reg]
kind =           "@opcode_kind.arch"
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.reg"]
templates =      [1,            0]
names =          ["",           "regid"]
constexprs =     [1]

#void write_reg<T> reg:id	T:value
[opcode.write_reg]
kind =           "@opcode_kind.arch"
side-effect    = true
template-count = 1
types =          ["@type.none", "@type.reg", "@type.none"]
templates =      [0,            0,           1]
names =          ["",           "regid",     "value"]
constexprs =     [1]

#T    load_mem<T>  segment:Seg pointer:adr	
[opcode.load_mem]
kind =           "@opcode_kind.memory"
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.segment", "@type.pointer"]
templates =      [1,            0,               0]
names =          ["",           "segment",       "pointer"]
constexprs =     [1]

#void store_mem<T> segment:Seg pointer:adr	T:value
[opcode.store_mem]
kind =           "@opcode_kind.memory"
side-effect    = true
template-count = 1
types =          ["@type.none", "@type.segment", "@type.pointer", "@type.none"]
templates =      [0,            0,               0,             1]
names =          ["",           "segment",       "pointer",     "value"]
constexprs =     [1]

#T    undef<T>
[opcode.undef]
kind =           "@opcode_kind.data"
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none"]
templates =      [1]
names =          [""]
constexprs =     []

#T    poison<T>    str:Reason
[opcode.poison]
kind =           "@opcode_kind.data"
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.str"]
templates =      [1,            0]
names =          ["",           "Reason"]
constexprs =     [1]

#Ty   cast_sx<Tx,Ty>  Tx:value
[opcode.cast_sx]
kind =           "@opcode_kind.cast"
is-const =       true
is-pure =        true
template-count = 2
types =          ["@type.none", "@type.none"]
templates =      [2,            1]
names =          ["",           "value"]
#Ty   cast<Tx,Ty>  Tx:value
[opcode.cast]
kind =           "@opcode_kind.cast"
is-const =       true
is-pure =        true
template-count = 2
types =          ["@type.none", "@type.none"]
templates =      [2,            1]
names =          ["",           "value"]
#Ty   bitcast<Tx,Ty>  Tx:value
[opcode.bitcast]
kind =           "@opcode_kind.cast"
is-const =       true
is-pure =        true
template-count = 2
types =          ["@type.none", "@type.none"]
templates =      [2,            1]
names =          ["",           "value"]

#T    binop<T>     Op:Operator  T:lhs  T:rhs
[opcode.binop]
kind =           "@opcode_kind.numeric"
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.op", "@type.none", "@type.none"]
templates =      [1,            0,          1,            1]
names =          ["",           "Op",       "lhs",        "rhs"]
constexprs =     [1]
#T    unop<T>     Op:Operator  T:rhs
[opcode.unop]
kind =           "@opcode_kind.numeric"
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.op", "@type.none"]
templates =      [1,            0,          1]
names =          ["",           "Op",       "rhs"]
constexprs =     [1]

#T    atomic_binop<T>     Op:Operator  segment:Seg  pointer:lhs_ptr T:rhs
[opcode.atomic_binop]
kind =           "@opcode_kind.numeric-rmw"
side-effect    = true
template-count = 1
types =          ["@type.none", "@type.op", "@type.segment", "@type.pointer", "@type.none"]
templates =      [1,            0,          0,               0,               1]
names =          ["",           "Op",       "segment",       "lhs_ptr",       "rhs"]
constexprs =     [1, 2]

#T    atomic_unop<T>     Op:Operator  segment:Seg  pointer:rhs_ptr
[opcode.atomic_unop]
kind =           "@opcode_kind.numeric-rmw"
side-effect    = true
template-count = 1
types =          ["@type.none", "@type.op", "@type.segment", "@type.pointer"]
templates =      [1,            0,          0,               0]
names =          ["",           "Op",       "segment",       "rhs_ptr"]
constexprs =     [1, 2]

#i1    cmp<T>     Op:Operator  T:lhs  T:rhs
[opcode.cmp]
kind =           "@opcode_kind.predicate"
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.i1", "@type.op", "@type.none", "@type.none"]
templates =      [0,          0,          1,            1]
names =          ["",         "Op", "lhs",        "rhs"]
constexprs =     [1]

#T     phi<T>     Tx...
[opcode.phi]
kind =           "@opcode_kind.phi"
template-count = 1
types =          ["@type.none", "@type.pack"]
templates =      [1,            0]
names =          ["",           "incoming"]

#T    select<T>   i1:cc  T:tv T:fv
[opcode.select]
kind =           "@opcode_kind.data"
is-const =       true
is-pure =        true
template-count = 1
types =          ["@type.none", "@type.i1", "@type.none", "@type.none"]
templates =      [1,            0,          1,            1]
names =          ["",           "cc",      "tv",          "fv"]

#void  xcall      pointer:destination
[opcode.xcall]
trashes-regs =   true
kind =           "@opcode_kind.external-branch"
side-effect    = true
template-count = 0
types =          ["@type.none", "@type.pointer"]
templates =      [0,            0]
names =          ["",           "destination"]

#void  xjmp      pointer:destination
[opcode.xjmp]
kind =           "@opcode_kind.external-branch"
side-effect    = true
terminator =     true
bb-terminator  = true
template-count = 0
types =          ["@type.none", "@type.pointer"]
templates =      [0,            0]
names =          ["",           "destination"]

#void  xjs       i1:cc  pointer:tb pointer:fb
[opcode.xjs]
kind =           "@opcode_kind.external-branch"
side-effect    = true
terminator =     true
bb-terminator  = true
types =          ["@type.none", "@type.i1", "@type.pointer", "@type.pointer"]
templates =      [0,            0,          0,            0]
names =          ["",           "cc",      "tb",          "fb"]

#void  jmp       label:destination
[opcode.jmp]
kind =           "@opcode_kind.branch"
side-effect    = true
terminator =     true
template-count = 0
types =          ["@type.none", "@type.label"]
templates =      [0,            0]
names =          ["",           "destination"]

#void  js        i1:cc  label:tb label:fb
[opcode.js]
kind =           "@opcode_kind.branch"
side-effect    = true
terminator =     true
types =          ["@type.none", "@type.i1", "@type.label", "@type.label"]
templates =      [0,            0,          0,            0]
names =          ["",           "cc",      "tb",          "fb"]

#void  ret<T>    T:result
[opcode.ret]
kind =           "@opcode_kind.branch"
side-effect    = true
terminator =     true
bb-terminator  = true
template-count = 1
types =          ["@type.none", "@type.none"]
templates =      [0,            1]
names =          ["",           "result"]

#void  trap      str:Reason
[opcode.trap]
kind =           "@opcode_kind.trap"
side-effect    = true
terminator =     true
bb-terminator  = true
template-count = 0
types =          ["@type.none", "@type.str"]
templates =      [0,            0]
names =          ["",           "Reason"]
constexprs =     [1]

#void  nop
[opcode.nop]
template-count = 0
types =          ["@type.none"]
templates =      [0]
names =          [""]

#void  unreachable
[opcode.unreachable]
kind =           "@opcode_kind.trap"
side-effect    = true
terminator =     true
bb-terminator  = true
template-count = 0
types =          ["@type.none"]
templates =      [0]
names =          [""]

#TODO:
#  -- vector stuff
#  T    intrinsic<T> constexpr intrinsic:Id, Ty:ArgOrTup // lsb,msb,popcnt,sin,cos,memcpy,atomic,can represent all things we dont care about
#  Tup  insert       Tup, int:idx, Ty:value
#  T    extract      Tup
#  R    call<R, A>   uptr:adr A:arg CC:CallConvention